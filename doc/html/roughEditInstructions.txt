All graphics in Transcend are generated by "object spaces" that map a [0, 1] parameter into a 2d object (an object made up of colored triangles and a line border).  Every parameter in the range [0,1] gives a slightly different object, and by changing the parameter slowly over time, the object will smoothly morph from one form to another.  

To relate this to something you have probably seen before:  Think about a color gradient, where 0 is red and 1 is green, and the color changes smoothly from red to green as you move from 0 to 1.  You can make the color bar more complicated by sticking a black control point at 0.25 and purple control point at 0.75.  Now the bar goes smoothly from red to black to purple to green.  You can add extra color control points and make a very complicated color bar.

Now imagine a spectrum of object shapes instead of colors.  Instead of having color control points, you have object control points that specify what the object should look like at a given point.  Thus, at 0 you could have a star shape, while at 1 you could have a square.  The spectrum would then blend smoothly from a star to a square, with 0.5 being an object that still looks a bit like a star but also looks a bit like a square.  If you stick a triangle shape control point in at 0.25, the spectrum will blend from a star to a triangle and then to a square. 

Making a Transcend level basically involves specifying a bunch of different object spaces (one for each object:  a space for enemies, another space for their bullets, a space for your ship, etc.).  In turn, specifying a space involves setting as many control points as you want in that space.  The minimum, of course, is 2 points per space (one at 0 and one at 1).  Each point has:

--An anchor in the range [0,1]
--A set of triangle vertices (each with X,Y and R,G,B,A)
--A set of border vertices (each with X,Y and R,G,B,A)
--A border width parameter
--A number of rotated copies (to create a "flower" type effect, with multiple copies of the shape rotated around a center)
--A scale factor for rotated copies (to create a spiral type effect, with each additional copy/"petal" getting smaller (or larger) than the last)
--A scale factor for the angle between copies.  With a factor of 1, the copies are spaced evenly around the circle.  Larger values spread the copies out more, and smaller values squeeze the copies closer together
--A rotation rate for the object (how fast it spins)


Here is a sample control point:


0

6

1.000000 0.000000
1.000000 0.000000 0.000000 1.000000
0.000000 -1.000000
1.000000 0.000000 0.000000 1.000000
0.000000 1.000000
0.000000 0.000000 0.000000 1.000000
0.000000 -1.000000
1.000000 0.000000 0.000000 1.000000
0.000000 1.000000
0.000000 0.000000 0.000000 1.000000
-1.000000 0.000000
1.000000 0.000000 0.000000 1.000000

4

-1.000000 1.000000
0.000000 0.000000 0.000000 0.000000
0.000000 -2.000000
0.000000 0.000000 0.000000 1.000000
1.000000 1.000000
0.000000 0.000000 0.000000 0.000000
0.000000 0.000000
1.000000 1.000000 1.000000 1.000000

2.000000
0.000000
1.000000
1.000000
0.000000


This point is anchored at parameter 0.  It has 6 triangle points (in other words, two triangles) and 4 border points.  Each vertex (either triangle or border) has an X,Y coordinate followed by an RGBA color.  Consider the first triangle vertex:

1.000000 0.000000
1.000000 0.000000 0.000000 1.000000

This vertex is at the point (1,0) and it has a color that is solid red.

At the end of the control point are 5 values (each on a separate line) that represent border width and the other parameters that apply to the entire object.  For example, this object has a border that is 2 pixels wide, there are no rotated copies (single object, does not look like a "flower"), and it doesn't rotate (rotation rate of 0).

This control point comes from the file 

levels/001/enemyBulletClose

and there is one other control point in that file.  That space determines how the enemy bullets look at close range, and there is a separate space for the far-range bullet shape.  Each enemy has a close range and a far range parameter, and the bullets blend smoothly from close shape to far shape as they move away from the firing enemy.  Thus, you can understand why every enemy has bullets that look slightly different.

One thing to keep in mind is a trick to ensure smooth object blending:

--All points in a given space should have the same number of triangle and border points, and the points on one control point should "correspond" with the same points, in order on the other control points.  If the number of triangles changes across an object spectrum, triangles will "pop in" or "pop out" during a blend, thus ruining the smooth effect.  Also, if you don't keep track of corresponding vertices across control points, you can get some "ugly" effects.  For example, if a left-most vertex from one control point is used as a right-most vertex in another control point, the object will "twist" across itself during a blend. 

As text objects, these control points are pretty scary:  it takes *forever* to edit a Transcend level by hand.

I have created an editor program for control points, but it is a little clunky.  It only can handle single control points and does not deal with entire spaces.  To use it, you must copy a control point into a separate, temp text file and open it with the editor.  After editing, you can save the control point and then copy the new text for that point back into your object space file.

Since the editor only deals with single points and not object spaces, you *should not* include the parameter anchor (the [0,1] value) in the temp text file.  Just the control point with no anchor (from above, you would start your copy-past selection at the "6".

The keyboard controls for the editor are described in the source:

Transcend/editors/doc/controls.txt

The best way to get the editor is to build it yourself from the source distribution.  Have you tried compiling the source yet?  After you have built the game, change to the editors directory and type:

make

to build the editor.  Then run the editor from the command line, passing in the name of the temp text file.
